MODULE p0(event)
    VAR
        state: 0 .. 4;
        T0R_requested: boolean;
        P0R_requested: boolean;
        P0L_requested: boolean;
        T0L_requested: boolean;
        must_finish: boolean;
    INIT
        state = 0
    ASSIGN
        T0R_requested :=
            case
                state = 0: TRUE;
                state = 1: FALSE;
                state = 2: FALSE;
                state = 3: TRUE;
                TRUE: FALSE;
            esac;
        P0R_requested :=
            case
                state = 0: FALSE;
                state = 1: TRUE;
                state = 2: TRUE;
                state = 3: FALSE;
                TRUE: FALSE;
            esac;
        P0L_requested :=
            case
                state = 0: FALSE;
                state = 1: TRUE;
                state = 2: TRUE;
                state = 3: FALSE;
                TRUE: FALSE;
            esac;
        T0L_requested :=
            case
                state = 0: TRUE;
                state = 1: FALSE;
                state = 2: FALSE;
                state = 3: TRUE;
                TRUE: FALSE;
            esac;
        next(state) :=
            case
                state = 0 & (next(event) = T0L | next(event) = T0R | FALSE): 3;
                state = 1 & (next(event) = P0L | next(event) = P0R | FALSE): 0;
                state = 2 & (next(event) = P0L | next(event) = P0R | FALSE): 1;
                state = 3 & (next(event) = T0L | next(event) = T0R | FALSE): 2;
                TRUE: state;
            esac;
        must_finish :=
            case
                FALSE: TRUE;
                state = 3 | state = 2 | state = 1 | state = 0 | FALSE: FALSE;
                TRUE: FALSE;
            esac;
MODULE p1(event)
    VAR
        state: 0 .. 4;
        T1R_requested: boolean;
        T1L_requested: boolean;
        P1L_requested: boolean;
        P1R_requested: boolean;
        must_finish: boolean;
    INIT
        state = 0
    ASSIGN
        T1R_requested :=
            case
                state = 0: TRUE;
                state = 1: FALSE;
                state = 2: TRUE;
                state = 3: FALSE;
                TRUE: FALSE;
            esac;
        T1L_requested :=
            case
                state = 0: TRUE;
                state = 1: FALSE;
                state = 2: TRUE;
                state = 3: FALSE;
                TRUE: FALSE;
            esac;
        P1L_requested :=
            case
                state = 0: FALSE;
                state = 1: TRUE;
                state = 2: FALSE;
                state = 3: TRUE;
                TRUE: FALSE;
            esac;
        P1R_requested :=
            case
                state = 0: FALSE;
                state = 1: TRUE;
                state = 2: FALSE;
                state = 3: TRUE;
                TRUE: FALSE;
            esac;
        next(state) :=
            case
                state = 0 & (next(event) = T1L | next(event) = T1R | FALSE): 2;
                state = 1 & (next(event) = P1L | next(event) = P1R | FALSE): 3;
                state = 2 & (next(event) = T1L | next(event) = T1R | FALSE): 1;
                state = 3 & (next(event) = P1L | next(event) = P1R | FALSE): 0;
                TRUE: state;
            esac;
        must_finish :=
            case
                FALSE: TRUE;
                state = 3 | state = 2 | state = 1 | state = 0 | FALSE: FALSE;
                TRUE: FALSE;
            esac;
MODULE f0(event)
    VAR
        state: 0 .. 3;
        T0R_blocked: boolean;
        T1L_blocked: boolean;
        P1L_blocked: boolean;
        P0R_blocked: boolean;
        must_finish: boolean;
    INIT
        state = 0
    ASSIGN
        T0R_blocked :=
            case
                state = 0: FALSE;
                state = 1: TRUE;
                state = 2: TRUE;
                TRUE: FALSE;
            esac;
        T1L_blocked :=
            case
                state = 0: FALSE;
                state = 1: TRUE;
                state = 2: TRUE;
                TRUE: FALSE;
            esac;
        P1L_blocked :=
            case
                state = 0: TRUE;
                state = 1: TRUE;
                state = 2: FALSE;
                TRUE: FALSE;
            esac;
        P0R_blocked :=
            case
                state = 0: TRUE;
                state = 1: FALSE;
                state = 2: TRUE;
                TRUE: FALSE;
            esac;
        next(state) :=
            case
                state = 0 & (next(event) = T0R | FALSE): 1;
                state = 0 & (next(event) = T1L | FALSE): 2;
                state = 1 & (next(event) = P0R | FALSE): 0;
                state = 2 & (next(event) = P1L | FALSE): 0;
                TRUE: state;
            esac;
        must_finish :=
            case
                FALSE: TRUE;
                state = 2 | state = 1 | state = 0 | FALSE: FALSE;
                TRUE: FALSE;
            esac;
MODULE f1(event)
    VAR
        state: 0 .. 3;
        T1R_blocked: boolean;
        P0L_blocked: boolean;
        P1R_blocked: boolean;
        T0L_blocked: boolean;
        must_finish: boolean;
    INIT
        state = 0
    ASSIGN
        T1R_blocked :=
            case
                state = 0: FALSE;
                state = 1: TRUE;
                state = 2: TRUE;
                TRUE: FALSE;
            esac;
        P0L_blocked :=
            case
                state = 0: TRUE;
                state = 1: FALSE;
                state = 2: TRUE;
                TRUE: FALSE;
            esac;
        P1R_blocked :=
            case
                state = 0: TRUE;
                state = 1: TRUE;
                state = 2: FALSE;
                TRUE: FALSE;
            esac;
        T0L_blocked :=
            case
                state = 0: FALSE;
                state = 1: TRUE;
                state = 2: TRUE;
                TRUE: FALSE;
            esac;
        next(state) :=
            case
                state = 0 & (next(event) = T1R | FALSE): 2;
                state = 0 & (next(event) = T0L | FALSE): 1;
                state = 1 & (next(event) = P0L | FALSE): 0;
                state = 2 & (next(event) = P1R | FALSE): 0;
                TRUE: state;
            esac;
        must_finish :=
            case
                FALSE: TRUE;
                state = 2 | state = 1 | state = 0 | FALSE: FALSE;
                TRUE: FALSE;
            esac;
MODULE f0r(event)
    VAR
        state: 0 .. 2;
        must_finish: boolean;
    INIT
        state = 0
    ASSIGN
        next(state) :=
            case
                state = 0 & (next(event) = T1L | next(event) = T0R | FALSE): 1;
                state = 1 & (next(event) = P1L | next(event) = P0R | FALSE): 0;
                TRUE: state;
            esac;
        must_finish :=
            case
                state = 1 | FALSE: TRUE;
                state = 0 | FALSE: FALSE;
                TRUE: FALSE;
            esac;
MODULE main
    VAR
        event: {START, DONE, T0R, T1R, T0L, T1L, P0R, P1R, P0L, P1L};
        event_START: boolean;
        event_DONE: boolean;
        event_T0R: boolean;
        event_T1R: boolean;
        event_T0L: boolean;
        event_T1L: boolean;
        event_P0R: boolean;
        event_P1R: boolean;
        event_P0L: boolean;
        event_P1L: boolean;
        bt0: p0(event);
        bt1: p1(event);
        bt2: f0(event);
        bt3: f1(event);
        bt4: f0r(event);
    INIT
        event = START
    DEFINE
        T0R_requested := bt0.T0R_requested | FALSE;
        T0R_blocked := bt2.T0R_blocked | FALSE;
        T1R_requested := bt1.T1R_requested | FALSE;
        T1R_blocked := bt3.T1R_blocked | FALSE;
        T0L_requested := bt0.T0L_requested | FALSE;
        T0L_blocked := bt3.T0L_blocked | FALSE;
        T1L_requested := bt1.T1L_requested | FALSE;
        T1L_blocked := bt2.T1L_blocked | FALSE;
        P0R_requested := bt0.P0R_requested | FALSE;
        P0R_blocked := bt2.P0R_blocked | FALSE;
        P1R_requested := bt1.P1R_requested | FALSE;
        P1R_blocked := bt3.P1R_blocked | FALSE;
        P0L_requested := bt0.P0L_requested | FALSE;
        P0L_blocked := bt3.P0L_blocked | FALSE;
        P1L_requested := bt1.P1L_requested | FALSE;
        P1L_blocked := bt2.P1L_blocked | FALSE;
        must_finish := bt4.must_finish | bt3.must_finish | bt2.must_finish | bt1.must_finish | bt0.must_finish | FALSE;
        T0R_enabled := T0R_requested & !T0R_blocked;
        T1R_enabled := T1R_requested & !T1R_blocked;
        T0L_enabled := T0L_requested & !T0L_blocked;
        T1L_enabled := T1L_requested & !T1L_blocked;
        P0R_enabled := P0R_requested & !P0R_blocked;
        P1R_enabled := P1R_requested & !P1R_blocked;
        P0L_enabled := P0L_requested & !P0L_blocked;
        P1L_enabled := P1L_requested & !P1L_blocked;
        DEADLOCK := (event != START) & !(T0R_enabled | T1R_enabled | T0L_enabled | T1L_enabled | P0R_enabled | P1R_enabled | P0L_enabled | P1L_enabled);
    TRANS
        next(event) != START & (!T0R_enabled -> next(event) != T0R) & (!T1R_enabled -> next(event) != T1R) & (!T0L_enabled -> next(event) != T0L) & (!T1L_enabled -> next(event) != T1L) & (!P0R_enabled -> next(event) != P0R) & (!P1R_enabled -> next(event) != P1R) & (!P0L_enabled -> next(event) != P0L) & (!P1L_enabled -> next(event) != P1L)
